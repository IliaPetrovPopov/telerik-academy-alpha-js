<img src="https://webassets.telerikacademy.com/images/default-source/logos/telerik-academy.svg)" alt="logo" width="300px" style="margin-top: 20px;"/>

# Recursion Advanced

### 1. Description

In this exercise, we are going to practice **a bit more advanced** classic problems involving recursion. Try your best by following the guides, debugging your implementation, and if all else fails, consulting with the solutions. These tasks are common interview questions and you are **very likely to encounter them again**.

### 2. Project information

- Requires node.js version >= 14
- Running:
  - `npm run permutations` - runs the **Permutations** task
  - `npm run mergesort` - runs the **Merge Sort** task
  - `npm run maze` - runs the **All Paths Through Maze** task
- The task setup is already done for you, **you must write code only in the provided function**.
- Consult with the @jsdoc above the function to get a better idea about the input parameters and the expected return value
- If still struggling, consult with the tests. They are located in the same file.

### 3. Tasks

#### 1. Permutations

The [permutations](https://www.careerbless.com/calculators/word/list.php) of a given string are the all possible arrangements of its characters. Generate all of the permutations and return them as a result. Implement `permutations` **recursively**:

```js
const permutations = (string) => {
  // your implementation:
};
```

The function takes a string and returns an array of all its possible permutations.

```
string: 'dsa'
returns: ['dsa', 'das', 'sda', 'sad', 'ads', 'asd']

string: ['a']
returns: ['a']
```

- Rule 1: All permutations of a string are generated by applying each of its characters to each of the available places
- Rule 2: The only permutation of a string with with 1 or 0 characters is the same string.
- _Hint:_
  - **'dsa' - 3 places: [ _, _ , _ ]**
  - **first place: [ d, _, _ ], [ s, _, _ ], [ a, _, _ ]**
  - **second place: [ d, s, _ ], [ d, a, _ ], [ s, d, _ ], [ s, a, _ ], [ a, s, _ ], [ a, d, _ ]**
  - **third place: [ d, s, a ], [ d, a, s ], [ s, d, a ], [ s, a, d ], [ a, s, d ], [ a, d, s ]**

#### 2. Merge Sort

Research the [Merge Sort Algorithm](https://www.geeksforgeeks.org/merge-sort/) and apply it to an array of numbers in an increasing order. Implement the `mergeSort` function **recursively**:

```js
const mergeSort = (numbers) => {
  // your implementation:
};
```

The function takes an array of numbers and applies the Merge Sort algorithm to sort them.

```
array: [5, 2, 3, 7, 1, 14]
returns: [1, 2, 3, 5, 7, 14]

array: [1]
returns: [1]
```

- Rule 1: A sorted array of **n** numbers (6 for example) is achieved by first sorting the left half **[0, n/2)** (first 3), then the right half **[n/2, n)** (second 3) and the merging and sorting the two already sorted halves.
- Rule 2: A sorted array of 1 or 0 elements is the same array.


#### 3. All Paths Through Maze [Advanced]

You will receive a maze (**matrix**) as a parameter and your task is to find all possible paths from the start **(0,0)** to the exit (**'e'**) in form of matrixes. The maze has a couple of different cells that you can see in the legend below. You can move only **up, left, down and right**. Follow the rules and step only in the available cells, mark them with **'v'** (visited) and when a viable path is found, save it (mark the other cells of the path with **null**). Implement `findAllPaths` **recursively**:

```js
const findAllPaths = (maze) => {
  // your implementation:
};
```

Legend:

```
' ' -> empty space - you are free to step there
'x' -> a wall - you cannot step there
'e' -> the exit - the cell you are searching for
'v' -> the marking - use it to mark your path path
```

The function takes a maze and returns an array of all possible paths.

```
maze: [
        [' ', ' ', ' '],
        [' ', 'x', ' '],
        [' ', ' ', ' '],
        ['x', ' ', 'e'],
      ],
returns: [
  [
    ['v', 'v', 'v'],
    [null, null, 'v'],
    [null, null, 'v'],
    [null, null, 'v'],
  ],
  [
    ['v', 'v', 'v'],
    [null, null, 'v'],
    [null, 'v', 'v'],
    [null, 'v', 'v'],
  ],
  [
    ['v', null, null],
    ['v', null, null],
    ['v', 'v', 'v'],
    [null, null, 'v'],
  ],
  [
    ['v', 'v', null],
    ['v', null, null],
    ['v', 'v', null],
    [null, 'v', 'v'],
  ],
],
```

- Rule 1: If the current cell is outside of the maze, you cant step there.
- Rule 2: If the current cell is a wall (**'x'**), you cant step there.
- Rule 3: If the current cell is visited (**'v'**), you cant step there.
- Rule 4: If the current cell is the exit (**'e'**), save the current path.
- Rule 5: If the current cell is empty (**' '**), mark the current cell as visited (**'v'**), check all possible paths (**up, left, down and right**) and then unmark the cell.
